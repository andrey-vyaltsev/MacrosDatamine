!START PLNCALC

!ONERR GOTO ERR

!SCROFF 

-- Расчёт элементов преобладающго залегания и запись их в результирующий файл
-- Используется метод наименьших квадратов 
-- Автор - Кирьяков Г.А. g-kir@yandex.ru
-- Вычищение ошибок - Некрасов А.А. :))
-- Версия от 24.01.2024
-- Подробное описание алгоритма взято с https://pikabu.ru/?target=8125372

==================================================
Блок настроек
==================================================

Входной файл точек
!LET $file_in# = ore_body_pt

Координатные поля во входном файле
!LET $x_crd# = XPT
!LET $y_crd# = YPT
!LET $z_crd# = ZPT

Поле зонального контроля во входном файле (если нет, оставить пустым)
!LET $zone_fld# = BODY_NUM

Выходной файл точек
!LET $file_ou# = ou_p1

Выходной файл-список со значениями среднего залегания
!LET $list_dir_ou# = dir_av_list

Поле азимута падения в выходном файле
!LET $dipdir_ou# = DIPDIR

Поле угла падения в выходном файле
!LET $dip_ou# = DIP

=========================================================================
Блок настроек закончен. Ниже ничего не трогать без согласования с автором
=========================================================================

!LET $DEBUG# = 0
!LET $debug_step# = 0

Описание алгоритма:
1. Подготовка данныхс
    а. В случае отсутствия поля зонального контроля - создание фиктивного, единого для всех точек.
       В случае наличия поля зонального контроля - сортировка данных по нему
    б. создание рабочей версии, которая состоит только из координатных полей и поля зонального контроля 

2. Обработка случая неравномерного распределения точек: расчёт геометрических центров и отражение данных относительно него
3. Собственно алгоритм МНК (описание алгоритма - либо по приведённой ссылке, либо в сопроводительной документации)
4. Из результирующего файла оставляем только порядковый номер и поля элементов залегания
5. Подшиваем поля элементов залегания к исходному файлу с помощью поля порядкового номера
6. Удаляем поле порядкового номера

Реализация алгоритма

!ECHO Подготавиливаю данные

1. Подготовка данных
    а. В случае отсутствия поля зонального контроля - создание фиктивного, единого для всех точек. 

!LET $tmp# = LENG($zone_fld#)

!IF $tmp# = 0, 
 
 !LET $need_zone# = 0

 !EXTRA    &IN($file_in#),
           &OUT(tmp_mac1),
           @APPROX=0.0

  DVOGJT = 1

 GO 

 !LET $zone_fld# = DVOGJT

!ELSEIF 

    В случае наличия поля зонального контроля - сортировка данных по нему
 
 !LET $need_zone# = 1

 !SORTX    &IN($file_in#),
           &OUT(tmp_mac1),
           *KEY1($zone_fld#),
           @BINS=5.0,
           @ORDER=1.0

!ENDIF 

    б. создание рабочей версии, которая состоит только из координатных полей, поля зонального контроля и поля порядковых номеров

!EXTRA    &IN(tmp_mac1)
          &OUT(tmp_mac1_),
          @APPROX=0.0

 saveonly($zone_fld#,$x_crd#,$y_crd#,$z_crd#)

GO 

----Проверка 1. Начало.----
!IF $DEBUG# = 1,THEN 
!PROMPT 
0 Проверка 1
1 Введите значение поля BODY в строке 35462 файла tmp_mac1_>'$t#'
!FIELD $file_name#=tmp_mac1_,$record_num#=35462,$test_true#=BODY
!IF $t# <> $test_true#,GOTO ERR
!ECHO Проверка 1 пройдена успешно!
!ENDIF 
----Проверка 1. Конец.----

!LET $debug_step# = 2

!ECHO Отражаю данные относительно геометрических центров (подстраховка от кластеризации данных)

2. Обработка случая неравномерного распределения точек: расчёт геометрических центров и отражение данных относительно него

!STATS    &IN(mp_mac1_),
          &OUT(tmp_mac_stat),
          *F1($x_crd#),
          *F2($y_crd#),
          *F3($z_crd#),
          *KEY1($zone_fld#),
          @KEYSORT=1.0,
          @KEYTOL=0.00001,
          @PCNTILES=1.0,
          @SORTOUT=1.0

!EXTRA    &IN(tmp_mac_stat),
          &OUT(tmp_mac_stat_x),
          @APPROX=0.0

 if ('FIELD' <> "$x_crd#")
  delete()
 endif
 X_CNTR = MEAN
 saveonly($zone_fld#,X_CNTR)

GO 

!EXTRA    &IN(tmp_mac_stat),
          &OUT(tmp_mac_stat_y),
          @APPROX=0.0

 if ('FIELD' <> "$y_crd#")
  delete()
 end
 Y_CNTR = MEAN
 saveonly($zone_fld#,Y_CNTR)

GO 

!EXTRA    &IN(tmp_mac_stat),
          &OUT(tmp_mac_stat_z),
          @APPROX=0.0

 if ('FIELD' <> "$z_crd#")
  delete()
 end
 Z_CNTR = MEAN
 save($zone_fld#,Z_CNTR)

GO 

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac_stat),
           @CONFIRM=0.0

!ENDIF 

!JOIN     &IN1(tmp_mac_stat_x),
          &IN2(tmp_mac_stat_y),
          &OUT(tmp_mac_stat_xy),
          *KEY1($zone_fld#),
          @SUBSETR=0.0,
          @SUBSETF=0.0,
          @CARTJOIN=0.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac_stat_x),
           @CONFIRM=0.0
 !DELETE   &IN(tmp_mac_stat_y),
           @CONFIRM=0.0

!ENDIF 

!JOIN     &IN1(tmp_mac_stat_xy),
          &IN2(tmp_mac_stat_z),
          &OUT(tmp_mac_stat_xyz),
          *KEY1($zone_fld#),
          @SUBSETR=0.0,
          @SUBSETF=0.0,
          @CARTJOIN=0.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac_stat_xy),
           @CONFIRM=0.0

 !DELETE   &IN(tmp_mac_stat_z),
           @CONFIRM=0.0

!ENDIF 

!JOIN     &IN1(tmp_mac1_),
          &IN2(tmp_mac_stat_xyz),
          &OUT(tmp_mac_)
          *KEY1($zone_fld#),
          @SUBSETR=0.0,
          @SUBSETF=0.0,
          @CARTJOIN=0.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac_stat_xyz),
           @CONFIRM=0.0

!ENDIF 

----Проверка 2. Начало.----
!IF $DEBUG# = 1,THEN 
!PROMPT 
0 Проверка 2
1 Введите ЦЕЛУЮ ЧАСТЬ значения поля X_CNTR в строке 2464 файла tmp_mac_>'$t#'
!FIELD $file_name#=tmp_mac_,$record_num#=2464,$test_true#=X_CNTR
!LET $test_true# = INT($test_true#)
!IF $t# <> $test_true#,GOTO ERR
!ECHO Проверка 2 пройдена успешно!
!ENDIF 
----Проверка 2. Конец.----

!LET $debug_step# = 3

отражение данных отностельно центров

!EXTRA    &IN(tmp_mac_),
          &OUT(tmp_mac__),
          @APPROX=0.0

 a = -($x_crd# - X_CNTR)
 b = -($y_crd# - Y_CNTR)
 c = -($z_crd# - Z_CNTR)
 $x_crd# = a + X_CNTR)
 $y_crd# = b + Y_CNTR
 $z_crd# = c + Z_CNTR
 saveonly($zone_fld#,$x_crd#,$y_crd#,$z_crd#)

GO 

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac_),
           @CONFIRM=0.0

!ENDIF 

!APPEND   &IN1(tmp_mac1_),
          &IN3(tmp_mac__),
          &OUT(_tmp_mac),
          @SEQUENCE=0.0,
          @PROTODD=0.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac1_),
           @CONFIRM=0.0

 !DELETE   &IN(tmp_mac__),
           @CONFIRM=0.0

!ENDIF 

!SORTX    &OUT(_tmp_mac),
          &IN(__tmp_mac),
          *KEY1($zone_fld#),
          @BINS=5.0,
          @ORDER=1.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(_tmp_mac),
           @CONFIRM=0.0

!ENDIF 


!EXTRA    &IN(__tmp_mac),
          &OUT(tmp_mac1__),
          @APPROX=0.0

 saveonly($zone_fld#,$x_crd#,$y_crd#,$z_crd#)

 GO 

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(__tmp_mac),
           @CONFIRM=0.0

!ENDIF 

----Проверка 3. Начало.----
!IF $DEBUG# = 1,THEN 
!PROMPT 
0 Проверка 3
1 Введите ЦЕЛУЮ ЧАСТЬ значения поля YP в строке 1104 файла tmp_mac1__>'$t#'
!FIELD $file_name#=tmp_mac1__,$record_num#=1104,$test_true#=YP
!LET $test_true# = INT($test_true#)
!IF $t# <> $test_true#,GOTO ERR
!ECHO Проверка 3 пройдена успешно!
!ENDIF 
----Проверка 3. Конец.----

!LET $debug_step# = 4

!ECHO Рассчитываю преобладающее залегание (формирую список)

Начало расчёта уравнения плоскости.
Нумерация шагов дана по https://pikabu.ru/?target=8125372

Шаг 1. Вычисляем 

"XX" = SUMM(x^2) - (SUMM(x))^2 / N

"YY" = SUMM(y^2) - (SUMM(y))^2 / N

"ZZ" = SUMM(z^2) - (SUMM(z))^2 / N

"XY" = SUMM(x * y) - SUMM(x) * SUMM(y) / N

"YZ" = SUMM(y * z) - SUMM(y) * SUMM(z) / N

"ZX" = SUMM(z * x) - SUMM(z) * SUMM(x) / N

!EXTRA    &IN(tmp_mac1__),
          &OUT(tmp_mac2),
          @APPROX=0.0

 x_kv = $x_crd# * $x_crd#
 y_kv = $y_crd# * $y_crd#
 z_kv = $z_crd# * $z_crd#
 x_y = $x_crd# * $y_crd#
 y_z = $y_crd# * $z_crd#
 z_x = $z_crd# * $x_crd#
 saveonly($zone_fld#,x_kv,y_kv,z_kv,x_y,y_z,z_x,
 $x_crd#,$y_crd#,$z_crd#)



!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac1__),
           @CONFIRM=0.0

!ENDIF 

!COUNT    &IN(tmp_mac2)
          &OUT(zone_mac_cnt),
          *KEY1($zone_fld#),
          @KEYSORT=1.0,
          @KEYTOL=0.00001

!ACCMLT   &IN(tmp_mac2),
          &OUT(tmp_mac3),
          *KEY1($zone_fld#),
          @ALLRECS=0.0,
          @UNSORTED=0.0

----Проверка 4. Начало.----
!IF $DEBUG# = 1,THEN 
!PROMPT 
0 Проверка 4
1 Введите значение поля BODY в строке 17 файла tmp_mac3 [0] > '$t#'
!FIELD $file_name#=tmp_mac3,$record_num#=17,$test_true#=BODY
!IF $t# <> $test_true#,GOTO ERR
!ECHO Проверка 4 пройдена успешно!
!ENDIF 
----Проверка 4. Конец.----

!LET $debug_step# = 5

!IF $DEBUG# = 0,THEN 
 
 !DELETE   &IN(mp_mac2),
           @CONFIRM=0.0

!ENDIF 

!JOIN     &IN1(tmp_mac3),
          &IN2(zone_mac_cnt),
          &OUT(tmp_mac4),
          *KEY1($zone_fld#),
          @SUBSETR=0.0,
          @SUBSETF=0.0,
          @CARTJOIN=0.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac3),
           @CONFIRM=0.0

 !DELETE   &IN(zone_mac_cnt),
           @CONFIRM=0.0

!ENDIF 

Дальше EXTRA, куда заложены шаги 2-7

Шаг 2 Вычисляем определители, составленные из этих чисел и единиц (см. описание расчётов)
Шаг 3 Вычисляем ненормированные коэффициенты
Шаг 4 Вычисляем длину вектора (A1,B1,C1)
Шаг 2’ Вычисляем определители другие (в первых строчках минусы перед единицами)
Шаг 3’ Вычисляем ненормированные коэффициенты со штрихами
Шаг 4’ Вычисляем длину вектора (A1’,B1’,C1’)
Шаг 5 Сравниваем, что больше L, или L’

Шаг 6 Если L > L’ тогда:

A = A1 / L
B = B1 / L
C = C1 / L

Шаг 6’ Если L < L’ тогда:

A = A1’ / L’
B = B1’ / L’
C = C1’ / L’

Шаг 7 Вычисляем D
D = - (A * SUMM(x) + B * SUMM(y) + C * SUMM(z)) / N

!EXTRA    &IN(tmp_mac4),
          &OUT($list_dir_ou#),
          @APPROX=0.0

 XX = x_kv - ($x_crd# * $x_crd#) / COUNT
 YY = y_kv - ($y_crd# * $y_crd#) / COUNT
 ZZ = z_kv - ($z_crd# * $z_crd#) / COUNT
 XY = x_y - ($x_crd# * $y_crd#) / COUNT
 YZ = y_z - ($y_crd# * $z_crd#) / COUNT
 ZX = z_x - ($z_crd# * $x_crd#) / COUNT
 DetA1 = YY * ZZ + XY * YZ + YZ * ZX - YY * ZX - XY * ZZ - YZ * YZ
 DetB1 = XX * ZZ + YZ * ZX + XY * ZX - ZX * ZX - YZ * XX - XY * ZZ
 DetC1 = XX * YY + XY * ZX + XY * YZ - ZX * YY - YZ * XX - XY * XY
 DetA11 =  - YY * ZZ + XY * YZ + YZ * ZX - YY * ZX - XY * ZZ + YZ * YZ
 DetB11 = XX * ZZ - YZ * ZX + XY * ZX - ZX * ZX - YZ * XX + XY * ZZ
 DetC11 = XX * YY + XY * ZX - XY * YZ + ZX * YY - YZ * XX - XY * XY
 L_v = SQRT(DetA1 * DetA1 + DetB1 * DetB1 + DetC1 * DetC1)
 L_v1 = SQRT(DetA11 * DetA11 + DetB11 * DetB11 + DetC11 * DetC11)
 if (L_v > L_v1)
  A_coef  =  DetA1 / L_v
  B_coef  =  DetB1 / L_v
  C_coef  =  DetC1 / L_v
 elseif
  A_coef = DetA11 / L_v1
  B_coef = DetB11 / L_v1
  C_coef = DetC11 / L_v1
 end
 D_coef =  -(A_coef * $x_crd# + B_coef * $y_crd# + C_coef * $z_crd#) / COUNT
 if (C_coef < 0)
  A_coef = - A_coef
  B_coef = - B_coef
  C_coef = - C_coef
  D_coef = - D_coef
 end
 $dip_ou# = ACOS(C_coef)
 if ($dip_ou#  == 0)
  $dipdir_ou# = 0
 end
 ABS_TAN = ABS(A_coef / B_coef)
 ABS_UG = ATAN(ABS_TAN)
 if (A_coef == 0)
  if (B_coef > 0)
   $dipdir_ou# = 90
  elseif
   $dipdir_ou# = 270
  end
 end
 if (B_coef == 0)
  if (A_coef > 0)
   $dipdir_ou# = 0
  elseif
   $dipdir_ou# = 180
  end
 end
 if ((A_coef <> 0) and (B_coef <> 0))
  if ((A_coef > 0) and (B_coef > 0))
   $dipdir_ou# = ABS_UG
  end
  if ((A_coef < 0) and (B_coef > 0))
   $dipdir_ou# = 360 - ABS_UG
  end
  if ((A_coef < 0) and (B_coef < 0))
   $dipdir_ou# = 180 + ABS_UG
  end
  if ((A_coef > 0) and (B_coef < 0))
   $dipdir_ou# = 180 - ABS_UG
  end
 end
 $dipdir_ou# = (INT($dipdir_ou#) + INT((($dipdir_ou#) - INT($dipdir_ou#)) / 0.5))
 $dip_ou# = (INT($dip_ou#) + INT((($dip_ou#) - INT($dip_ou#)) / 0.5))
 saveonly($zone_fld#,$dipdir_ou#,$dip_ou#)

GO 

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac4),
           @CONFIRM=0.0

!ENDIF 

----Проверка 5. Начало.----
!IF $DEBUG# = 1,THEN 
!PROMPT 
0 Проверка 5
1 Введите значение поля DIP в строке 20 файла $list_dir_ou# [0] > '$t#'
!FIELD $file_name#=$list_dir_ou#,$record_num#=20,$test_true#=DIP
!IF $t# <> $test_true#,GOTO ERR
!ECHO Проверка 5 пройдена успешно!
!ENDIF 
----Проверка 5. Конец.----

!LET $debug_step# = 6

!LET $next_file# = $file_ou#

!IF $need_zone# = 0,THEN 

 !LET $next_file# = tmp_mac5

!ENDIF 

!ECHO Переношу преобладающее залегание в итоговый файл

5. Подшиваем поля элементов залегания к исходному файлу с помощью поля зонального контроля

!JOIN     &IN1(tmp_mac1),
          &IN2(list_dir_ou#),
          &OUT($next_file#),
          *KEY1($zone_fld#),
          @SUBSETR=0.0,
          @SUBSETF=0.0,
          @CARTJOIN=0.0

!IF $DEBUG# = 0,THEN 

 !DELETE   &IN(tmp_mac1),
           @CONFIRM=0.0
!ENDIF 

!IF $need_zone# = 0,THEN 

 !EXTRA    &IN(tmp_mac5),
           &OUT($file_ou)#,
           @APPROX=0.0

  erase($zone_fld#)

 GO 

 !IF $DEBUG# = 0,THEN 

  !DELETE   &IN(tmp_mac5),
            @CONFIRM=0.0

 !ENDIF 

!ENDIF 

----Проверка 6. Начало.----
!IF $DEBUG# = 1,THEN 
!PROMPT 
0 Проверка 6
1 Введите значение поля DIPDIR в строке 29244 файла $file_ou# [0] > '$t#'
!FIELD $file_name#=$file_ou#,$record_num#=29244,$test_true#=DIPDIR
!IF $t# <> $test_true#,GOTO ERR
!ECHO Проверка 6 пройдена успешно!
!ENDIF 
----Проверка 6. Конец.----

!SCRON 

!GOTO SUCSESS

!ERR:REM 

!VARSAVE debug.var

!ECHO !!!OOPS!!!ERROR!!!

!ECHO Check debug.var

!GOTO FIN

!SUCSESS:ECHO Work finished succsessfully

!FIN:REM 

!END 